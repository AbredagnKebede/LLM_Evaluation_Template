I need you to prepare comprehensive test suite inside @tests.py  for a code that will be generated by the prompt @prompt.md 

Use prompt.md as a sole context to prepare the tests. The tests must cover all cases, like cases that even the best programer in the world would forget to consider while responding, and also check if any code that is generated by the prompt is exactly in a way told by the prompt. 

The purpose of this tests is to find the failing cases of different implementations of prompt.md and exposing the weakness of the codes(response as the whole).

The tests needs to be atleast 10 but can be more to cover all cases. 

Use unittest only. Assume the functions cited in the prompt are avaliable in the ideal_code.py that is avaliabel in the same dir as tests.py.

Iteratively check all unit tests to make sure they are all correct and asserting the right value. 

The test should look something like:
```
import unittest
import random
import time
import math
from concurrent.futures import ThreadPoolExecutor
from ideal_code import (
    simulate_satellite_data_processing,
    _partition_data,
    _process_chunk_with_randomization,
    _merge_sorted_lists,
    _parallel_merge
)


class TestSatelliteDataProcessing(unittest.TestCase):
    """
    Comprehensive test suite for satellite data processing system.
    Tests cover all requirements, constraints, and edge cases to expose implementation weaknesses.
    """

    def test_basic_functionality_small_dataset(self):
        """
        Test basic functionality with small dataset from prompt examples.
        Verifies the main function works correctly with provided sample inputs.
        """
        test_data = [5, 1, 3, 7, 9, 2, 8, 4, 6, 0]
        result = simulate_satellite_data_processing(test_data)
        expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        self.assertEqual(result, expected)

    def test_basic_functionality_with_duplicates(self):
        """
        Test functionality with duplicate values as shown in second prompt example.
        Ensures duplicate handling works correctly in the sorting process.
        """
        test_data = [15, 8, 23, 4, 16, 42, 8, 15]
        result = simulate_satellite_data_processing(test_data)
        expected = [4, 8, 8, 15, 15, 16, 23, 42]
        self.assertEqual(result, expected)

    def test_memory_efficiency_large_dataset(self):
        """
        Test that the algorithm doesn't use excessive memory.
        Many LLMs create unnecessary copies or use inefficient data structures.
        """
        # Test with maximum size dataset
        test_data = list(range(10000))
        random.shuffle(test_data)
        
        # This is a basic memory test - in a real scenario you'd use memory profiling
        # For now, we just ensure it completes without memory issues
        result = simulate_satellite_data_processing(test_data)
        self.assertEqual(result, sorted(test_data))
        
        # Verify the result is a proper list, not some other data structure
        self.assertIsInstance(result, list)
        self.assertEqual(len(result), 10000)

    def test_concurrent_access_safety(self):
        """
        Test that the functions are thread-safe for parallel execution.
        Many LLMs don't consider thread safety in their implementations.
        """
        test_data = [random.randint(1, 100) for _ in range(100)]
        
        def process_data():
            return simulate_satellite_data_processing(test_data)
        
        # Run multiple threads concurrently
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(process_data) for _ in range(4)]
            results = [future.result() for future in futures]
        
        # All results should be correct and identical
        expected = sorted(test_data)
        for result in results:
            self.assertEqual(result, expected)

    def test_merge_sorted_lists_with_negative_duplicates(self):
        """
        Test merge with negative duplicates - common LLM oversight.
        Many LLMs don't handle negative duplicates properly.
        """
        left = [-5, -3, -1]
        right = [-4, -2, -1]  # -1 is duplicate
        result = _merge_sorted_lists(left, right)
        expected = [-5, -4, -3, -2, -1, -1]a
        self.assertEqual(result, expected, "Negative duplicates merge failed")


if __name__ == '__main__':
    unittest.main()
```
And the ideal_code that is at the import of the sample test above, assume it is like a code that is the prefect response for the prompt inside @prompt.md, but when generating the test you only depend on the prompt.md not the ideal_code for now.
I have attached @prompt.md file
